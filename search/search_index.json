{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u0415\u043b\u0438\u0437\u0430\u0432\u0435\u0442\u0430 \u0418\u0432\u0435\u043d\u043a\u043e\u0432\u0430, \u0433\u0440\u0443\u043f\u043f\u0430 K33422","title":"Home"},{"location":"#k33422","text":"","title":"\u0415\u043b\u0438\u0437\u0430\u0432\u0435\u0442\u0430 \u0418\u0432\u0435\u043d\u043a\u043e\u0432\u0430, \u0433\u0440\u0443\u043f\u043f\u0430 K33422"},{"location":"lab1/ex1/","text":"\u0423\u043f\u0440\u0430\u0436\u0435\u043d\u0435\u043d\u0438\u0435 1 \u041a\u043e\u0434 \u041a\u043b\u0438\u0435\u043d\u0442\u0430 import socket def main(): client_connection = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) client_connection.connect(('127.0.0.1', 14900)) client_connection.send(b'Hello, server') server_msg = client_connection.recv(12000).decode('utf-8') print(server_msg) client_connection.close() if __name__ == '__main__': main() \u0421\u0435\u0440\u0432\u0435\u0440\u0430 import socket def main(): client_connection = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) client_connection.bind(('127.0.0.1', 14900)) data, client_address = client_connection.recvfrom(12000) decoded_data = data.decode('utf-8') print(decoded_data) client_connection.sendto(b\"Hello, client\", client_address) client_connection.close() if __name__ == '__main__': main()","title":"\u0423\u043f\u0440\u0430\u0436\u0435\u043d\u0435\u043d\u0438\u0435 1"},{"location":"lab1/ex1/#1","text":"","title":"\u0423\u043f\u0440\u0430\u0436\u0435\u043d\u0435\u043d\u0438\u0435 1"},{"location":"lab1/ex1/#_1","text":"","title":"\u041a\u043e\u0434"},{"location":"lab1/ex1/#_2","text":"import socket def main(): client_connection = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) client_connection.connect(('127.0.0.1', 14900)) client_connection.send(b'Hello, server') server_msg = client_connection.recv(12000).decode('utf-8') print(server_msg) client_connection.close() if __name__ == '__main__': main()","title":"\u041a\u043b\u0438\u0435\u043d\u0442\u0430"},{"location":"lab1/ex1/#_3","text":"import socket def main(): client_connection = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) client_connection.bind(('127.0.0.1', 14900)) data, client_address = client_connection.recvfrom(12000) decoded_data = data.decode('utf-8') print(decoded_data) client_connection.sendto(b\"Hello, client\", client_address) client_connection.close() if __name__ == '__main__': main()","title":"\u0421\u0435\u0440\u0432\u0435\u0440\u0430"},{"location":"lab1/ex2/","text":"\u0423\u043f\u0440\u0430\u0436\u043d\u0435\u043d\u0438\u0435 2 \u041a\u043e\u0434 \u041a\u043b\u0438\u0435\u043d\u0442\u0430 import socket import pickle def main(): server_connection = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_connection.connect(('127.0.0.1', 14900)) base = int(input('Base:')) height = int(input('Height:')) parallelogram_data = (base, height) encoded_parallelogram_data = pickle.dumps(parallelogram_data) server_connection.send(encoded_parallelogram_data) server_response_enc = server_connection.recv(12000) server_response_dec = server_response_enc.decode('utf-8') print(f'Parallelogram area: {server_response_dec}') server_connection.close() if __name__ == '__main__': main() \u0421\u0435\u0440\u0432\u0435\u0440\u0430 import socket import pickle def main(): server_connection = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_connection.bind(('127.0.0.1', 14900)) client_connection, address = server_connection.accept() encoded_data = client_connection.recv(12000) base, height = pickle.loads(encoded_data) area = base * height area = round(area, 2) area_encoded = str(area).encode('utf-8') client_connection.send(area_encoded) server_connection.close() if __name__ == '__main__': main()","title":"\u0423\u043f\u0440\u0430\u0436\u043d\u0435\u043d\u0438\u0435 2"},{"location":"lab1/ex2/#2","text":"","title":"\u0423\u043f\u0440\u0430\u0436\u043d\u0435\u043d\u0438\u0435 2"},{"location":"lab1/ex2/#_1","text":"","title":"\u041a\u043e\u0434"},{"location":"lab1/ex2/#_2","text":"import socket import pickle def main(): server_connection = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_connection.connect(('127.0.0.1', 14900)) base = int(input('Base:')) height = int(input('Height:')) parallelogram_data = (base, height) encoded_parallelogram_data = pickle.dumps(parallelogram_data) server_connection.send(encoded_parallelogram_data) server_response_enc = server_connection.recv(12000) server_response_dec = server_response_enc.decode('utf-8') print(f'Parallelogram area: {server_response_dec}') server_connection.close() if __name__ == '__main__': main()","title":"\u041a\u043b\u0438\u0435\u043d\u0442\u0430"},{"location":"lab1/ex2/#_3","text":"import socket import pickle def main(): server_connection = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_connection.bind(('127.0.0.1', 14900)) client_connection, address = server_connection.accept() encoded_data = client_connection.recv(12000) base, height = pickle.loads(encoded_data) area = base * height area = round(area, 2) area_encoded = str(area).encode('utf-8') client_connection.send(area_encoded) server_connection.close() if __name__ == '__main__': main()","title":"\u0421\u0435\u0440\u0432\u0435\u0440\u0430"},{"location":"lab1/ex3/","text":"\u0423\u043f\u0440\u0430\u0436\u043d\u0435\u043d\u0438\u0435 3 \u041a\u043e\u0434 \u0421\u0435\u0440\u0432\u0435\u0440 import socket def get_webpage_response(): response_type = 'HTTP/1.0 200 OK\\n' headers = 'Content-Type: text/html\\n\\n' with open('index.html') as f: content = \"\".join(f.readlines()) response_raw = response_type + headers + content response_encoded = response_raw.encode('utf-8') return response_encoded def main(): server_connection = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_connection.bind(('127.0.0.1', 14900)) server_connection.listen(10) print(f'\u041f\u0435\u0440\u0435\u0445\u043e\u0434\u0438 \u043f\u043e \u0430\u0434\u0440\u0435\u0441\u0443: 127.0.0.1:14900') while True: try: client_connection, address = server_connection.accept() print(client_connection) webpage_response = get_webpage_response() client_connection.send(webpage_response) except KeyboardInterrupt: break server_connection.close() if __name__ == '__main__': main() index.html <!DOCTYPE html> <html> <head> <title>The best website ever existed</title> </head> <body> Lorem Ipsum Dolor Sit O Met </body> </html>","title":"\u0423\u043f\u0440\u0430\u0436\u043d\u0435\u043d\u0438\u0435 3"},{"location":"lab1/ex3/#3","text":"","title":"\u0423\u043f\u0440\u0430\u0436\u043d\u0435\u043d\u0438\u0435 3"},{"location":"lab1/ex3/#_1","text":"","title":"\u041a\u043e\u0434"},{"location":"lab1/ex3/#_2","text":"import socket def get_webpage_response(): response_type = 'HTTP/1.0 200 OK\\n' headers = 'Content-Type: text/html\\n\\n' with open('index.html') as f: content = \"\".join(f.readlines()) response_raw = response_type + headers + content response_encoded = response_raw.encode('utf-8') return response_encoded def main(): server_connection = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_connection.bind(('127.0.0.1', 14900)) server_connection.listen(10) print(f'\u041f\u0435\u0440\u0435\u0445\u043e\u0434\u0438 \u043f\u043e \u0430\u0434\u0440\u0435\u0441\u0443: 127.0.0.1:14900') while True: try: client_connection, address = server_connection.accept() print(client_connection) webpage_response = get_webpage_response() client_connection.send(webpage_response) except KeyboardInterrupt: break server_connection.close() if __name__ == '__main__': main()","title":"\u0421\u0435\u0440\u0432\u0435\u0440"},{"location":"lab1/ex3/#indexhtml","text":"<!DOCTYPE html> <html> <head> <title>The best website ever existed</title> </head> <body> Lorem Ipsum Dolor Sit O Met </body> </html>","title":"index.html"},{"location":"lab1/ex4/","text":"\u0423\u043f\u0440\u0430\u0436\u0435\u043d\u0435\u043d\u0438\u0435 4 \u0420\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u041a\u043b\u0438\u0435\u043d\u0442\u0430 \u041a\u043b\u0438\u0435\u043d\u0442 \u0438\u043c\u0435\u0435\u0442 2 \u043f\u043e\u0442\u043e\u043a\u0430. \u041e\u0434\u0438\u043d \u0434\u043b\u044f \u0432\u0432\u043e\u0434\u0430 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0439. \u0414\u0440\u0443\u0433\u043e\u0439 \u0434\u043b\u044f \u0432\u044b\u0432\u043e\u0434\u0430 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0439 import socket import concurrent.futures import threading stop_event = threading.Event() def input_thread(conn: socket.socket): \"\"\"\u041f\u043e\u0442\u043e\u043a \u0434\u043b\u044f \u0432\u0432\u043e\u0434\u0430 \u0434\u0430\u043d\u043d\u044b\u0445\"\"\" while not stop_event.is_set(): msg = input() msg_encoded = msg.encode() conn.send(msg_encoded) if msg == 'Bye!': print('Stopped everything') stop_event.set() conn.close() def msg_printer_thread(conn: socket.socket): \"\"\"\u041f\u043e\u0442\u043e\u043a \u0434\u043b\u044f \u0432\u044b\u0432\u043e\u0434\u0430 \u0434\u0430\u043d\u043d\u044b\u0445\"\"\" while not stop_event.is_set(): msg = conn.recv(13000) print(msg.decode('utf-8')) def main(): conn = socket.socket(socket.AF_INET, socket.SOCK_STREAM) conn.connect(('127.0.0.1', 14900)) with concurrent.futures.ThreadPoolExecutor() as executor: executor.submit(input_thread, conn) executor.submit(msg_printer_thread, conn) if __name__ == '__main__': main() \u0421\u0435\u0440\u0432\u0435\u0440\u0430 \u0421\u0435\u0440\u0432\u0435\u0440 \u0438\u043c\u0435\u0435\u0442 3 \u043f\u043e\u0442\u043e\u043a\u0430: \u041f\u043e\u0442\u043e\u043a \u0434\u043b\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0438 \u043d\u043e\u0432\u044b\u0445 \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0439 \u041f\u043e\u0442\u043e\u043a \u0434\u043b\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0439 \u0441\u043e\u043e\u0431\u0449\u0435\u0439\u043d\u0438 \u043e\u0442 \u043a\u043e\u043d\u043a\u0440\u0435\u0442\u043d\u043e\u0433\u043e \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f(\u0438\u0445 \u043c\u043e\u0436\u0435\u0442 \u0431\u044b\u0442\u044c \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u043e) \u041f\u043e\u0442\u043e\u043a \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0438 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0439 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f\u043c 2 \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u0438\u0445 \u043f\u043e\u0442\u043e\u043a\u0430 \u043e\u0431\u0449\u0430\u044f\u044e\u0442\u0441\u044f \u0434\u0440\u0443\u0433 \u0441 \u0434\u0440\u0443\u0433\u043e\u043c \u043f\u0440\u0438 \u043f\u043e\u043c\u043e\u0449\u0438 msg_queue import socket from queue import Queue from concurrent import futures import threading from dataclasses import dataclass from typing import Dict @dataclass(frozen=True) class Client(): \"\"\" \u041e\u0431\u044a\u0435\u043a\u0442 \u043a\u043b\u0438\u0435\u043d\u0442\u0430 \"\"\" conn: socket.socket stop_event: threading.Event \"\"\"\u0421\u043e\u0431\u044b\u0442\u0438\u0435 \u043e\u0441\u0442\u043e\u043d\u043e\u0432\u043a\u0438 \u043f\u043e\u0442\u043e\u043a\u0430\"\"\" id_client_dict: Dict[int, Client] = {} # \u041e\u0447\u0435\u0440\u0435\u043b\u044c \u0441 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f\u043c\u0438, \u043f\u0440\u0438 \u043f\u043e\u043c\u043e\u0449\u0438 \u043a\u043e\u0442\u043e\u0440\u043e\u0439 \u0432\u0437\u0430\u0438\u043c\u043e\u0434\u0435\u0439\u0441\u0442\u0432\u0443\u044e\u0442 client_thread \u0438 sender_thread msg_queue = Queue() def main_thread(): \"\"\"\u041e\u0441\u043d\u043e\u0432\u043d\u043e\u0439 \u043f\u043e\u0442\u043e\u043a, \u0438\u0437 \u043a\u043e\u0442\u043e\u0440\u043e\u0433\u043e \u0437\u0430\u043f\u0443\u0441\u043a\u0430\u044e\u0442\u0441\u044f \u0432\u0441\u0435 \u043e\u0441\u0442\u0430\u043b\u044c\u043d\u044b\u0435\"\"\" conn = socket.socket(socket.AF_INET, socket.SOCK_STREAM) conn.bind(('127.0.0.1', 14900)) conn.listen(10) new_client_id = 0 with futures.ThreadPoolExecutor() as executor: # \u0417\u0430\u043f\u0443\u0441\u043a\u0430\u0435\u043c \u043f\u043e\u0442\u043e\u043a \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0438 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0439 executor.submit(sender_thread) while True: # \u041f\u0440\u0438\u043d\u0438\u043c\u0430\u0435\u043c \u043a\u043b\u0438\u0435\u043d\u0442\u0430 client_conn, address = conn.accept() client_conn.send(f'Server: you have received id {new_client_id}'.encode('utf-8')) # \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u044d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440 \u043a\u043b\u0438\u0435\u043d\u0442\u0430 client = Client(client_conn, threading.Event()) # \u0417\u0430\u043f\u0438\u0441\u044b\u0432\u0430\u0435\u043c \u043a\u043b\u0438\u0435\u043d\u0442\u0430 \u0432 \u0441\u043b\u043e\u0432\u0430\u0440\u044c id_client_dict[new_client_id] = client # \u0417\u0430\u043f\u0443\u0441\u043a\u0430\u0435\u043c \u043f\u043e\u0442\u043e\u043a \u0434\u043b\u044f \u043a\u043b\u0438\u0435\u043d\u0442\u0430 executor.submit(client_thread, client, new_client_id) new_client_id += 1 def client_thread(client: Client, _id): \"\"\"\u0412\u044b\u043f\u043e\u043b\u043d\u044f\u0435\u0442 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0443 \u043f\u043e\u0441\u0442\u0443\u043f\u0430\u044e\u0449\u0438\u0439 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0439 \u043e\u0442 \u043a\u043b\u0438\u0435\u043d\u0442\u0430\"\"\" while not client.stop_event.is_set(): client_msg = client.conn.recv(15000).decode('utf-8') msg_queue.put((client_msg, _id)) def sender_thread(): \"\"\"\u0420\u0430\u0441\u0441\u044b\u043b\u043a\u0430 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0439 \u0438\u0437 \u043e\u0447\u0435\u0440\u0435\u0434\u0438\"\"\" while True: msg, sender_id = msg_queue.get() for _id, client in id_client_dict.items(): if sender_id != _id: client.conn.send(f'{sender_id}:{msg}'.encode()) # \u041e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0430 \u0432\u044b\u0445\u043e\u0434\u0430 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u0438\u0437 \u0447\u0430\u0442\u0430 if msg == 'Bye!': sender_client = id_client_dict[sender_id] sender_client.stop_event.set() del id_client_dict[sender_id] if __name__ == '__main__': main_thread()","title":"\u0423\u043f\u0440\u0430\u0436\u0435\u043d\u0435\u043d\u0438\u0435 4"},{"location":"lab1/ex4/#4","text":"","title":"\u0423\u043f\u0440\u0430\u0436\u0435\u043d\u0435\u043d\u0438\u0435 4"},{"location":"lab1/ex4/#_1","text":"","title":"\u0420\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f"},{"location":"lab1/ex4/#_2","text":"\u041a\u043b\u0438\u0435\u043d\u0442 \u0438\u043c\u0435\u0435\u0442 2 \u043f\u043e\u0442\u043e\u043a\u0430. \u041e\u0434\u0438\u043d \u0434\u043b\u044f \u0432\u0432\u043e\u0434\u0430 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0439. \u0414\u0440\u0443\u0433\u043e\u0439 \u0434\u043b\u044f \u0432\u044b\u0432\u043e\u0434\u0430 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0439 import socket import concurrent.futures import threading stop_event = threading.Event() def input_thread(conn: socket.socket): \"\"\"\u041f\u043e\u0442\u043e\u043a \u0434\u043b\u044f \u0432\u0432\u043e\u0434\u0430 \u0434\u0430\u043d\u043d\u044b\u0445\"\"\" while not stop_event.is_set(): msg = input() msg_encoded = msg.encode() conn.send(msg_encoded) if msg == 'Bye!': print('Stopped everything') stop_event.set() conn.close() def msg_printer_thread(conn: socket.socket): \"\"\"\u041f\u043e\u0442\u043e\u043a \u0434\u043b\u044f \u0432\u044b\u0432\u043e\u0434\u0430 \u0434\u0430\u043d\u043d\u044b\u0445\"\"\" while not stop_event.is_set(): msg = conn.recv(13000) print(msg.decode('utf-8')) def main(): conn = socket.socket(socket.AF_INET, socket.SOCK_STREAM) conn.connect(('127.0.0.1', 14900)) with concurrent.futures.ThreadPoolExecutor() as executor: executor.submit(input_thread, conn) executor.submit(msg_printer_thread, conn) if __name__ == '__main__': main()","title":"\u041a\u043b\u0438\u0435\u043d\u0442\u0430"},{"location":"lab1/ex4/#_3","text":"\u0421\u0435\u0440\u0432\u0435\u0440 \u0438\u043c\u0435\u0435\u0442 3 \u043f\u043e\u0442\u043e\u043a\u0430: \u041f\u043e\u0442\u043e\u043a \u0434\u043b\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0438 \u043d\u043e\u0432\u044b\u0445 \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0439 \u041f\u043e\u0442\u043e\u043a \u0434\u043b\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0439 \u0441\u043e\u043e\u0431\u0449\u0435\u0439\u043d\u0438 \u043e\u0442 \u043a\u043e\u043d\u043a\u0440\u0435\u0442\u043d\u043e\u0433\u043e \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f(\u0438\u0445 \u043c\u043e\u0436\u0435\u0442 \u0431\u044b\u0442\u044c \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u043e) \u041f\u043e\u0442\u043e\u043a \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0438 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0439 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f\u043c 2 \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u0438\u0445 \u043f\u043e\u0442\u043e\u043a\u0430 \u043e\u0431\u0449\u0430\u044f\u044e\u0442\u0441\u044f \u0434\u0440\u0443\u0433 \u0441 \u0434\u0440\u0443\u0433\u043e\u043c \u043f\u0440\u0438 \u043f\u043e\u043c\u043e\u0449\u0438 msg_queue import socket from queue import Queue from concurrent import futures import threading from dataclasses import dataclass from typing import Dict @dataclass(frozen=True) class Client(): \"\"\" \u041e\u0431\u044a\u0435\u043a\u0442 \u043a\u043b\u0438\u0435\u043d\u0442\u0430 \"\"\" conn: socket.socket stop_event: threading.Event \"\"\"\u0421\u043e\u0431\u044b\u0442\u0438\u0435 \u043e\u0441\u0442\u043e\u043d\u043e\u0432\u043a\u0438 \u043f\u043e\u0442\u043e\u043a\u0430\"\"\" id_client_dict: Dict[int, Client] = {} # \u041e\u0447\u0435\u0440\u0435\u043b\u044c \u0441 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f\u043c\u0438, \u043f\u0440\u0438 \u043f\u043e\u043c\u043e\u0449\u0438 \u043a\u043e\u0442\u043e\u0440\u043e\u0439 \u0432\u0437\u0430\u0438\u043c\u043e\u0434\u0435\u0439\u0441\u0442\u0432\u0443\u044e\u0442 client_thread \u0438 sender_thread msg_queue = Queue() def main_thread(): \"\"\"\u041e\u0441\u043d\u043e\u0432\u043d\u043e\u0439 \u043f\u043e\u0442\u043e\u043a, \u0438\u0437 \u043a\u043e\u0442\u043e\u0440\u043e\u0433\u043e \u0437\u0430\u043f\u0443\u0441\u043a\u0430\u044e\u0442\u0441\u044f \u0432\u0441\u0435 \u043e\u0441\u0442\u0430\u043b\u044c\u043d\u044b\u0435\"\"\" conn = socket.socket(socket.AF_INET, socket.SOCK_STREAM) conn.bind(('127.0.0.1', 14900)) conn.listen(10) new_client_id = 0 with futures.ThreadPoolExecutor() as executor: # \u0417\u0430\u043f\u0443\u0441\u043a\u0430\u0435\u043c \u043f\u043e\u0442\u043e\u043a \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0438 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0439 executor.submit(sender_thread) while True: # \u041f\u0440\u0438\u043d\u0438\u043c\u0430\u0435\u043c \u043a\u043b\u0438\u0435\u043d\u0442\u0430 client_conn, address = conn.accept() client_conn.send(f'Server: you have received id {new_client_id}'.encode('utf-8')) # \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u044d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440 \u043a\u043b\u0438\u0435\u043d\u0442\u0430 client = Client(client_conn, threading.Event()) # \u0417\u0430\u043f\u0438\u0441\u044b\u0432\u0430\u0435\u043c \u043a\u043b\u0438\u0435\u043d\u0442\u0430 \u0432 \u0441\u043b\u043e\u0432\u0430\u0440\u044c id_client_dict[new_client_id] = client # \u0417\u0430\u043f\u0443\u0441\u043a\u0430\u0435\u043c \u043f\u043e\u0442\u043e\u043a \u0434\u043b\u044f \u043a\u043b\u0438\u0435\u043d\u0442\u0430 executor.submit(client_thread, client, new_client_id) new_client_id += 1 def client_thread(client: Client, _id): \"\"\"\u0412\u044b\u043f\u043e\u043b\u043d\u044f\u0435\u0442 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0443 \u043f\u043e\u0441\u0442\u0443\u043f\u0430\u044e\u0449\u0438\u0439 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0439 \u043e\u0442 \u043a\u043b\u0438\u0435\u043d\u0442\u0430\"\"\" while not client.stop_event.is_set(): client_msg = client.conn.recv(15000).decode('utf-8') msg_queue.put((client_msg, _id)) def sender_thread(): \"\"\"\u0420\u0430\u0441\u0441\u044b\u043b\u043a\u0430 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0439 \u0438\u0437 \u043e\u0447\u0435\u0440\u0435\u0434\u0438\"\"\" while True: msg, sender_id = msg_queue.get() for _id, client in id_client_dict.items(): if sender_id != _id: client.conn.send(f'{sender_id}:{msg}'.encode()) # \u041e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0430 \u0432\u044b\u0445\u043e\u0434\u0430 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u0438\u0437 \u0447\u0430\u0442\u0430 if msg == 'Bye!': sender_client = id_client_dict[sender_id] sender_client.stop_event.set() del id_client_dict[sender_id] if __name__ == '__main__': main_thread()","title":"\u0421\u0435\u0440\u0432\u0435\u0440\u0430"},{"location":"lab1/ex5/","text":"\u0423\u043f\u0440\u0430\u0436\u043d\u0435\u043d\u0438\u0435 5 \u041a\u043e\u0434 \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430 import socket import logging from io import BufferedWriter, BufferedReader import email.parser import email.message from urllib.parse import parse_qs, urlparse from dataclasses import dataclass from typing import List, Tuple, Dict class Request: \"\"\" Class containing request data \"\"\" def __init__(self, method, target, version, headers, rfile): self.method = method # get, post ... self.target = target # url self.version = version self.headers = headers # self.rfile = rfile @property def url_path(self): return self.url.path @property def url_params(self): return parse_qs(self.url.query) @property def url(self): return urlparse(self.target) @property def body(self): size = self.headers.get('Content-Length') if not size: return None else: size = int(size) return self.rfile.read(size) class ConnWriter: \"\"\" Wrapper around file interface of socket \"\"\" encoding = 'iso-8859-1' def __init__(self, wfile: BufferedWriter): self._wfile = wfile def encode_and_write(self, s: str): if not s.endswith('\\r\\n'): s += '\\r\\n' encoded = s.encode(self.encoding) self._wfile.write(encoded) def write_empty_line(self): self._wfile.write(b'\\r\\n') def write_bytes(self, s: bytes): if not s.endswith(b'\\r\\n'): s += b'\\r\\n' self._wfile.write(s) def __enter__(self): return self def __exit__(self, exc_type, exc_val, exc_tb): self._wfile.flush() self._wfile.close() @dataclass(frozen=True) class Response: \"\"\" Dataclass from which response created \"\"\" status: int reason: str headers: List[Tuple] = None body: bytes = None class MyHTTPServer: \"\"\" Accept requests, generate responses \"\"\" def __init__(self, host, port, server_name): self._host = host self._port = port self._server_name = server_name self.marks: Dict[str, List[int]] = {\"Math\": [5], 'Programming': [4]} \"\"\"Dict to imitate database. Already packed with some values\"\"\" def serve_forever(self): \"\"\" Starts server. Main function of a class \"\"\" conn = socket.socket(socket.AF_INET, socket.SOCK_STREAM, proto=0) try: conn.bind((self._host, self._port)) conn.listen(10) while True: client_conn, client_address = conn.accept() self.serve_client(client_conn) finally: conn.close() def serve_client(self, client_conn): \"\"\" Get response from a client and send appropriate response \"\"\" request = self.parse_request(client_conn) response = self.handle_request(request) self.send_response(client_conn, response) def parse_request(self, conn): \"\"\" Convert request into Request instance \"\"\" rfile = conn.makefile('rb') method, target, version = self.parse_request_line(rfile) logging.debug(f'request_line: {method} {target} {version}') headers = self.parse_headers(rfile) logging.debug(f'headers:\\n{headers}') self.check_host(headers) return Request(method, target, version, headers, rfile) def parse_request_line(self, rfile): request_line = rfile.readline().decode('iso-8859-1') request_line = request_line.rstrip('\\r\\n') method, target, version = request_line.split() if version != 'HTTP/1.1': raise Exception('Invalid HTTP version') return method, target, version def parse_headers(self, rfile: BufferedReader) -> email.message.Message: headers_list = [] while True: line = rfile.readline() if line in (b'\\r\\n', b'\\n', b''): break headers_list.append(line) headers_str = b''.join(headers_list).decode('iso-8859-1') return email.parser.Parser().parsestr(headers_str) def check_host(self, headers): \"\"\"Is host correct?\"\"\" host = headers.get('Host', '') logging.debug(f'host: {host}') if not host: raise Exception('Request without host') if host not in (self._server_name, f'{self._host}:{self._port}'): raise Exception('Invalid host') def handle_request(self, request:Request) -> Response: \"\"\"Handle different types of request. Even if this request is not supported\"\"\" if request.method == 'GET' and request.url_path == '/': return self.handle_get_mark(request) if request.method == 'POST' and request.url_path =='/update_marks': return self.handle_post_update_marks(request) if request.method == 'GET' and request.url_path == \"/update_marks\": return self.handle_get_update_marks(request) if request.method == 'GET' and request.url_path == '/favicon.ico': return Response(200, 'OK') return self.handle_404(request) def handle_post_update_marks(self, request: Request): body_encoded = request.body body_decoded = body_encoded.decode('iso-8859-1') parameters = parse_qs(body_decoded) if 'mark' not in parameters: raise Exception('No mark in post') if 'subject' not in parameters: raise Exception('No subject in post') mark = parameters['mark'][0] if not mark.isnumeric(): raise Exception('Invalid mark') mark = int(mark) subject = parameters['subject'][0] if subject not in self.marks: self.marks[subject] = [] self.marks[subject].append(mark) return Response(204, 'Created') def handle_get_mark(self, request: Request): content_type = 'text/html; charset=utf-8' body = '<html><head>' body += \"\"\"<style> table { border-collapse: collapse; } th, td { border: 1px solid black; text-align: center; padding: 8px; } </style>\"\"\" body += '</head><body>' body += '<table>' for subject in self.marks: body += '<tr>' body += f'<td>{subject}</td>' for mark in self.marks[subject]: body += f'<td>{mark}</td>' body += '</tr>' body += '</table>' body += '</body></html>' body = body.encode('utf-8') headers = [('Content-Type', content_type), ('Content-Length', len(body))] return Response(200, 'OK', headers, body) def handle_404(self, request: Request): body = '<html><head></head><body><h1>404 not found</h1></body>' body = body.encode('utf-8') content_type = 'text/html; charset=utf-8' headers = [('Content-Type', content_type), ('Content-Length', len(body))] return Response(404, 'Not Found', headers, body) def handle_get_update_marks(self, request): with open('update_marks.html') as f: body = ''.join(f.readlines()) body = body.encode('utf-8') headers = [('Content-Type', 'text/html; charset=utf-8'), ('Content-Length', len(body))] return Response(200, 'OK', headers, body) def send_response(self, conn: socket.socket, resp: Response): \"\"\"Convert Response class instance into appropriate test and sends it via socket\"\"\" with ConnWriter(conn.makefile('wb')) as wfile_wrapped: status_line = f'HTTP/1.1 {resp.status} {resp.reason}' wfile_wrapped.encode_and_write(status_line) if resp.headers is not None: for key, value in resp.headers: header_line = f'{key}: {value}' wfile_wrapped.encode_and_write(header_line) wfile_wrapped.write_empty_line() if resp.body is not None: wfile_wrapped.write_bytes(resp.body) if __name__ == '__main__': format = \"%(asctime)s: %(message)s\" logging.basicConfig(format=format, level=logging.INFO, datefmt=\"%H:%M:%S\") host = '127.0.0.1' port = 14900 print('\u0421\u0441\u044b\u043b\u043a\u0438:\\n' '\u041e\u0446\u0435\u043d\u043a\u0438: 127.0.0.1:14900\\n' '\u0414\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u043e\u0446\u0435\u043d\u043e\u043a: 127.0.0.1:14900/update_marks\\n') name = 'example.local' server = MyHTTPServer(host, port, name) server.serve_forever() \u041a\u043e\u0434 update_marks.html ```html Update marks Input mark Input subject","title":"\u0423\u043f\u0440\u0430\u0436\u043d\u0435\u043d\u0438\u0435 5"},{"location":"lab1/ex5/#5","text":"","title":"\u0423\u043f\u0440\u0430\u0436\u043d\u0435\u043d\u0438\u0435 5"},{"location":"lab1/ex5/#_1","text":"","title":"\u041a\u043e\u0434"},{"location":"lab1/ex5/#_2","text":"import socket import logging from io import BufferedWriter, BufferedReader import email.parser import email.message from urllib.parse import parse_qs, urlparse from dataclasses import dataclass from typing import List, Tuple, Dict class Request: \"\"\" Class containing request data \"\"\" def __init__(self, method, target, version, headers, rfile): self.method = method # get, post ... self.target = target # url self.version = version self.headers = headers # self.rfile = rfile @property def url_path(self): return self.url.path @property def url_params(self): return parse_qs(self.url.query) @property def url(self): return urlparse(self.target) @property def body(self): size = self.headers.get('Content-Length') if not size: return None else: size = int(size) return self.rfile.read(size) class ConnWriter: \"\"\" Wrapper around file interface of socket \"\"\" encoding = 'iso-8859-1' def __init__(self, wfile: BufferedWriter): self._wfile = wfile def encode_and_write(self, s: str): if not s.endswith('\\r\\n'): s += '\\r\\n' encoded = s.encode(self.encoding) self._wfile.write(encoded) def write_empty_line(self): self._wfile.write(b'\\r\\n') def write_bytes(self, s: bytes): if not s.endswith(b'\\r\\n'): s += b'\\r\\n' self._wfile.write(s) def __enter__(self): return self def __exit__(self, exc_type, exc_val, exc_tb): self._wfile.flush() self._wfile.close() @dataclass(frozen=True) class Response: \"\"\" Dataclass from which response created \"\"\" status: int reason: str headers: List[Tuple] = None body: bytes = None class MyHTTPServer: \"\"\" Accept requests, generate responses \"\"\" def __init__(self, host, port, server_name): self._host = host self._port = port self._server_name = server_name self.marks: Dict[str, List[int]] = {\"Math\": [5], 'Programming': [4]} \"\"\"Dict to imitate database. Already packed with some values\"\"\" def serve_forever(self): \"\"\" Starts server. Main function of a class \"\"\" conn = socket.socket(socket.AF_INET, socket.SOCK_STREAM, proto=0) try: conn.bind((self._host, self._port)) conn.listen(10) while True: client_conn, client_address = conn.accept() self.serve_client(client_conn) finally: conn.close() def serve_client(self, client_conn): \"\"\" Get response from a client and send appropriate response \"\"\" request = self.parse_request(client_conn) response = self.handle_request(request) self.send_response(client_conn, response) def parse_request(self, conn): \"\"\" Convert request into Request instance \"\"\" rfile = conn.makefile('rb') method, target, version = self.parse_request_line(rfile) logging.debug(f'request_line: {method} {target} {version}') headers = self.parse_headers(rfile) logging.debug(f'headers:\\n{headers}') self.check_host(headers) return Request(method, target, version, headers, rfile) def parse_request_line(self, rfile): request_line = rfile.readline().decode('iso-8859-1') request_line = request_line.rstrip('\\r\\n') method, target, version = request_line.split() if version != 'HTTP/1.1': raise Exception('Invalid HTTP version') return method, target, version def parse_headers(self, rfile: BufferedReader) -> email.message.Message: headers_list = [] while True: line = rfile.readline() if line in (b'\\r\\n', b'\\n', b''): break headers_list.append(line) headers_str = b''.join(headers_list).decode('iso-8859-1') return email.parser.Parser().parsestr(headers_str) def check_host(self, headers): \"\"\"Is host correct?\"\"\" host = headers.get('Host', '') logging.debug(f'host: {host}') if not host: raise Exception('Request without host') if host not in (self._server_name, f'{self._host}:{self._port}'): raise Exception('Invalid host') def handle_request(self, request:Request) -> Response: \"\"\"Handle different types of request. Even if this request is not supported\"\"\" if request.method == 'GET' and request.url_path == '/': return self.handle_get_mark(request) if request.method == 'POST' and request.url_path =='/update_marks': return self.handle_post_update_marks(request) if request.method == 'GET' and request.url_path == \"/update_marks\": return self.handle_get_update_marks(request) if request.method == 'GET' and request.url_path == '/favicon.ico': return Response(200, 'OK') return self.handle_404(request) def handle_post_update_marks(self, request: Request): body_encoded = request.body body_decoded = body_encoded.decode('iso-8859-1') parameters = parse_qs(body_decoded) if 'mark' not in parameters: raise Exception('No mark in post') if 'subject' not in parameters: raise Exception('No subject in post') mark = parameters['mark'][0] if not mark.isnumeric(): raise Exception('Invalid mark') mark = int(mark) subject = parameters['subject'][0] if subject not in self.marks: self.marks[subject] = [] self.marks[subject].append(mark) return Response(204, 'Created') def handle_get_mark(self, request: Request): content_type = 'text/html; charset=utf-8' body = '<html><head>' body += \"\"\"<style> table { border-collapse: collapse; } th, td { border: 1px solid black; text-align: center; padding: 8px; } </style>\"\"\" body += '</head><body>' body += '<table>' for subject in self.marks: body += '<tr>' body += f'<td>{subject}</td>' for mark in self.marks[subject]: body += f'<td>{mark}</td>' body += '</tr>' body += '</table>' body += '</body></html>' body = body.encode('utf-8') headers = [('Content-Type', content_type), ('Content-Length', len(body))] return Response(200, 'OK', headers, body) def handle_404(self, request: Request): body = '<html><head></head><body><h1>404 not found</h1></body>' body = body.encode('utf-8') content_type = 'text/html; charset=utf-8' headers = [('Content-Type', content_type), ('Content-Length', len(body))] return Response(404, 'Not Found', headers, body) def handle_get_update_marks(self, request): with open('update_marks.html') as f: body = ''.join(f.readlines()) body = body.encode('utf-8') headers = [('Content-Type', 'text/html; charset=utf-8'), ('Content-Length', len(body))] return Response(200, 'OK', headers, body) def send_response(self, conn: socket.socket, resp: Response): \"\"\"Convert Response class instance into appropriate test and sends it via socket\"\"\" with ConnWriter(conn.makefile('wb')) as wfile_wrapped: status_line = f'HTTP/1.1 {resp.status} {resp.reason}' wfile_wrapped.encode_and_write(status_line) if resp.headers is not None: for key, value in resp.headers: header_line = f'{key}: {value}' wfile_wrapped.encode_and_write(header_line) wfile_wrapped.write_empty_line() if resp.body is not None: wfile_wrapped.write_bytes(resp.body) if __name__ == '__main__': format = \"%(asctime)s: %(message)s\" logging.basicConfig(format=format, level=logging.INFO, datefmt=\"%H:%M:%S\") host = '127.0.0.1' port = 14900 print('\u0421\u0441\u044b\u043b\u043a\u0438:\\n' '\u041e\u0446\u0435\u043d\u043a\u0438: 127.0.0.1:14900\\n' '\u0414\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u043e\u0446\u0435\u043d\u043e\u043a: 127.0.0.1:14900/update_marks\\n') name = 'example.local' server = MyHTTPServer(host, port, name) server.serve_forever()","title":"\u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430"},{"location":"lab1/ex5/#update_markshtml","text":"```html Update marks Input mark Input subject","title":"\u041a\u043e\u0434 update_marks.html"}]}